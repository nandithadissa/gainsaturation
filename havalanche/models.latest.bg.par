* Copyright (c) 1994-2015 Synopsys, Inc.
* This parameter file and the associated documentation are proprietary
* to Synopsys, Inc.  This parameter file may only be used in accordance
* with the terms and conditions of a written license agreement with
* Synopsys, Inc.  All other use, reproduction, or distribution of this
* parameter file is strictly prohibited.


Material = "InAlAs" {
*  Mole dependent material: InAlAs (x=0) = InAs
*  Mole dependent material: InAlAs (x=1) = AlAs

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 14.55	# [1]
	epsilon(1)	= 10.06	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 14.55	# [1]
	epsilon(1)	= 10.06	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	refractiveindex(0)	= 3.892	# [1]
	refractiveindex(1)	= 2.90805	# [1]
	alpha(0)	= 2.0000e-04	# [1/K]
	alpha(1)	= 2.0000e-04	# [1/K]
	CarrDepCoeff(0)	= 1	# [1]
	CarrDepCoeff(1)	= 1	# [1]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0(0)	= 3.892	# [1]
	n_0(1)	= 2.90805	# [1]
	k_0(0)	= 0.0000e+00	# [1]
	k_0(1)	= 0.0000e+00	# [1]
	Cn_lambda(0)	= 0.0000e+00	# [um^-1]
	Cn_lambda(1)	= 0.0000e+00	# [um^-1]
	Dn_lambda(0)	= 0.0000e+00	# [um^-2]
	Dn_lambda(1)	= 0.0000e+00	# [um^-2]
	Ck_lambda(0)	= 0.0000e+00	# [um^-1]
	Ck_lambda(1)	= 0.0000e+00	# [um^-1]
	Dk_lambda(0)	= 0.0000e+00	# [um^-2]
	Dk_lambda(1)	= 0.0000e+00	# [um^-2]
	Cn_temp(0)	= 2.0000e-04	# [K^-1]
	Cn_temp(1)	= 2.0000e-04	# [K^-1]
	Cn_carr(0)	= 1	# [1]
	Cn_carr(1)	= 1	# [1]
	Cn_gain(0)	= 0.0000e+00	# [1]
	Cn_gain(1)	= 0.0000e+00	# [1]
	Npar(0)	= 1.0000e+18	# [cm^-3]
	Npar(1)	= 1.0000e+18	# [cm^-3]
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	Ck_carr(0)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Ck_carr(1)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Gamma_k_carr(0)	= 1,	1	#[1]
	Gamma_k_carr(1)	= 1,	1	#[1]
        Formula = 0
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	cv(0)	= 1.6	# [J/(Kcm^3)]
	cv(1)	= 1.16	# [J/(Kcm^3)]
	cv_b(0)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_b(1)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_c(0)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_c(1)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_d(0)	= 0.0000e+00	# [J/(K^4*cm^3)]
	cv_d(1)	= 0.0000e+00	# [J/(K^4*cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 3.7	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 1.1	# [(K cm)/W]
	B(1/kappa(1))	= -2.0000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 3.7	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 1.1	# [(K cm)/W]
	B(1/kappa(1))	= -2.0000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter dEg0(OldSlotboom):
	Eg0 = 1.56e+0 # [eV] only set this value
	Eg0(0)	= 1.56e+0	# [eV]
	
	* parameter Bgn2Chi:
	Xmax(0)	= 0.0000e+00	# [1]
	Bgn2Chi(0)	= 0.5	# [1]
	Xmax(1)	= 0.56	# [1]
	Bgn2Chi(1)	= 0.5	# [1]
	B(Bgn2Chi(1))	= 0.0000e+00	# [1]
	C(Bgn2Chi(1))	= 0.0000e+00	# [1]
	Xmax(2)	= 1	# [1]
	Bgn2Chi(2)	= 0.5	# [1]
	B(Bgn2Chi(2))	= 0.0000e+00	# [1]
	C(Bgn2Chi(2))	= 0.0000e+00	# [1]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha(0)	= 3.3500e-04	# [eV/K]
	Xmax(1)	= 0.56	# [1]
	alpha(1)	= 3.7140e-04	# [eV/K]
	B(alpha(1))	= 0.0000e+00	# [eV/K]
	C(alpha(1))	= 0.0000e+00	# [eV/K]
	Xmax(2)	= 1	# [1]
	alpha(2)	= 4.0000e-04	# [eV/K]
	B(alpha(2))	= 0.0000e+00	# [eV/K]
	C(alpha(2))	= 0.0000e+00	# [eV/K]

	* parameter alpha2:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha2(0)	= 0.0000e+00	# [eV/K]
	Xmax(1)	= 0.56	# [1]
	alpha2(1)	= 0.0000e+00	# [eV/K]
	B(alpha2(1))	= 0.0000e+00	# [eV/K]
	C(alpha2(1))	= 0.0000e+00	# [eV/K]
	Xmax(2)	= 1	# [1]
	alpha2(2)	= 0.0000e+00	# [eV/K]
	B(alpha2(2))	= 0.0000e+00	# [eV/K]
	C(alpha2(2))	= 0.0000e+00	# [eV/K]

	* parameter beta:
	Xmax(0)	= 0.0000e+00	# [1]
	beta(0)	= 2.4800e+02	# [K]
	Xmax(1)	= 0.56	# [1]
	beta(1)	= 1.0912e+02	# [K]
	B(beta(1))	= 0.0000e+00	# [K]
	C(beta(1))	= 0.0000e+00	# [K]
	Xmax(2)	= 1	# [1]
	beta(2)	= 0.0000e+00	# [K]
	B(beta(2))	= 0.0000e+00	# [K]
	C(beta(2))	= 0.0000e+00	# [K]

	* parameter beta2:
	Xmax(0)	= 0.0000e+00	# [1]
	beta2(0)	= 0.0000e+00	# [K]
	Xmax(1)	= 0.56	# [1]
	beta2(1)	= 0.0000e+00	# [K]
	B(beta2(1))	= 0.0000e+00	# [K]
	C(beta2(1))	= 0.0000e+00	# [K]
	Xmax(2)	= 1	# [1]
	beta2(2)	= 0.0000e+00	# [K]
	B(beta2(2))	= 0.0000e+00	# [K]
	C(beta2(2))	= 0.0000e+00	# [K]

	* parameter Chi0:
	Xmax(0)	= 0.0000e+00	# [1]
	Chi0(0)	= 4.92751	# [eV]
	Xmax(1)	= 0.56	# [1]
	Chi0(1)	= 4.1617	# [eV]
	B(Chi0(1))	= 0.0000e+00	# [eV]
	C(Chi0(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	Chi0(2)	= 3.56	# [eV]
	B(Chi0(2))	= 0.0000e+00	# [eV]
	C(Chi0(2))	= 0.0000e+00	# [eV]

	* parameter WorkFunction:
	Xmax(0)	= 0.0000e+00	# [1]
	WorkFunction(0)	= 4.25	# [eV]
	Xmax(1)	= 0.56	# [1]
	WorkFunction(1)	= 4.25	# [eV]
	B(WorkFunction(1))	= 0.0000e+00	# [eV]
	C(WorkFunction(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	WorkFunction(2)	= 4.25	# [eV]
	B(WorkFunction(2))	= 0.0000e+00	# [eV]
	C(WorkFunction(2))	= 0.0000e+00	# [eV]

	* parameter FermiEnergy:
	Xmax(0)	= 0.0000e+00	# [1]
	FermiEnergy(0)	= 11.7	# [eV]
	Xmax(1)	= 0.56	# [1]
	FermiEnergy(1)	= 11.7	# [eV]
	B(FermiEnergy(1))	= 0.0000e+00	# [eV]
	C(FermiEnergy(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	FermiEnergy(2)	= 11.7	# [eV]
	B(FermiEnergy(2))	= 0.0000e+00	# [eV]
	C(FermiEnergy(2))	= 0.0000e+00	# [eV]

	* parameter EgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	EgMin(0)	= -1.0000e+01	# [eV]
	Xmax(1)	= 0.56	# [1]
	EgMin(1)	= -1.0000e+01	# [eV]
	B(EgMin(1))	= 0.0000e+00	# [eV]
	C(EgMin(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	EgMin(2)	= -1.0000e+01	# [eV]
	B(EgMin(2))	= 0.0000e+00	# [eV]
	C(EgMin(2))	= 0.0000e+00	# [eV]

	* parameter dEgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	dEgMin(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 0.56	# [1]
	dEgMin(1)	= 0.0000e+00	# [eV]
	B(dEgMin(1))	= 0.0000e+00	# [eV]
	C(dEgMin(1))	= 0.0000e+00	# [eV]
	Xmax(2)	= 1	# [1]
	dEgMin(2)	= 0.0000e+00	# [eV]
	B(dEgMin(2))	= 0.0000e+00	# [eV]
	C(dEgMin(2))	= 0.0000e+00	# [eV]

}


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  JainRoulston { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	fcaalpha_n(0)	= 4.0000e-18	# [cm^2]
	fcaalpha_n(1)	= 4.0000e-18	# [cm^2]
	fcaalpha_p(0)	= 8.0000e-18	# [cm^2]
	fcaalpha_p(1)	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	gamma_1(0)	= 20.4	# [1]
	gamma_1(1)	= 3.45	# [1]
	gamma_2(0)	= 8.3	# [1]
	gamma_2(1)	= 0.68	# [1]
	gamma_3(0)	= 9.1	# [1]
	gamma_3(1)	= 1.29	# [1]
	so(0)	= 0.38	# [eV]
	so(1)	= 0.28	# [eV]
	ep_te(0)	= 21.5	# [eV]
	ep_te(1)	= 21.1	# [eV]
	ep_tm(0)	= 21.5	# [eV]
	ep_tm(1)	= 21.1	# [eV]
	A1(0)	= 0.0000e+00	# [1]
	A1(1)	= 0.0000e+00	# [1]
	A2(0)	= 0.0000e+00	# [1]
	A2(1)	= 0.0000e+00	# [1]
	A3(0)	= 0.0000e+00	# [1]
	A3(1)	= 0.0000e+00	# [1]
	A4(0)	= 0.0000e+00	# [1]
	A4(1)	= 0.0000e+00	# [1]
	A5(0)	= 0.0000e+00	# [1]
	A5(1)	= 0.0000e+00	# [1]
	A6(0)	= 0.0000e+00	# [1]
	A6(1)	= 0.0000e+00	# [1]
	cr(0)	= 0.0000e+00	# [eV]
	cr(1)	= 0.0000e+00	# [eV]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a_nu(0)	= 1	# [eV]
	a_nu(1)	= 2.47	# [eV]
	a_c(0)	= -5.0800e+00	# [eV]
	a_c(1)	= -5.6400e+00	# [eV]
	b_shear(0)	= -1.8000e+00	# [eV]
	b_shear(1)	= -1.5000e+00	# [eV]
	C_11(0)	= 8.329	# [1e-2 GPa]
	C_11(1)	= 5.34	# [1e-2 GPa]
	C_12(0)	= 4.526	# [1e-2 GPa]
	C_12(1)	= 12.5	# [1e-2 GPa]
	eps(0)	= 0.0000e+00	# [1]
	eps(1)	= 0.0000e+00	# [1]
	a0(0)	= 6.0583e-10	# [m]
	a0(1)	= 5.6611e-10	# [m]
	alpha(0)	= 2.7400e-15	# [m/K]
	alpha(1)	= 2.9000e-15	# [m/K]
	D1(0)	= 0.0000e+00	# [eV]
	D1(1)	= 0.0000e+00	# [eV]
	D2(0)	= 0.0000e+00	# [eV]
	D2(1)	= 0.0000e+00	# [eV]
	D3(0)	= 0.0000e+00	# [eV]
	D3(1)	= 0.0000e+00	# [eV]
	D4(0)	= 0.0000e+00	# [eV]
	D4(1)	= 0.0000e+00	# [eV]
	C_13(0)	= 0.0000e+00	# [1e-2 GPa]
	C_13(1)	= 0.0000e+00	# [1e-2 GPa]
	C_33(0)	= 0.0000e+00	# [1e-2 GPa]
	C_33(1)	= 0.0000e+00	# [1e-2 GPa]
	c0(0)	= 0.0000e+00	# [cm]
	c0(1)	= 0.0000e+00	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.1905	# [1]
	a(1)	= 0.1905	# [1]
	ml(0)	= 0.9163	# [1]
	ml(1)	= 0.9163	# [1]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nc300(0)	= 8.7200e+16	# [cm-3]
	Nc300(1)	= 1.1100e+18	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.443587	# [1]
	a(1)	= 0.443587	# [1]
	b(0)	= 3.6095e-03	# [K^-1]
	b(1)	= 3.6095e-03	# [K^-1]
	c(0)	= 1.1735e-04	# [K^-2]
	c(1)	= 1.1735e-04	# [K^-2]
	d(0)	= 1.2632e-06	# [K^-3]
	d(1)	= 1.2632e-06	# [K^-3]
	e(0)	= 3.0256e-09	# [K^-4]
	e(1)	= 3.0256e-09	# [K^-4]
	f(0)	= 4.6834e-03	# [K^-1]
	f(1)	= 4.6834e-03	# [K^-1]
	g(0)	= 2.2869e-04	# [K^-2]
	g(1)	= 2.2869e-04	# [K^-2]
	h(0)	= 7.4693e-07	# [K^-3]
	h(1)	= 7.4693e-07	# [K^-3]
	i(0)	= 1.7275e-09	# [K^-4]
	i(1)	= 1.7275e-09	# [K^-4]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nv300(0)	= 6.6600e+18	# [cm-3]
	Nv300(1)	= 1.2400e+19	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A(0)	= 4.22	# [1]
	A(1)	= 4.22	# [1]
	B(0)	= 0.6084	# [1]
	B(1)	= 0.6084	# [1]
	C(0)	= 23.058	# [1]
	C(1)	= 23.058	# [1]
	ml(0)	= 0.024	# [1]
	ml(1)	= 0.26	# [1]
	mh(0)	= 0.41	# [1]
	mh(1)	= 0.5	# [1]
	me(0)	= 0.0000e+00	# [1]
	me(1)	= 0.0000e+00	# [1]
	eoffset(0)	= 0.0000e+00	# [eV]
	eoffset(1)	= 0.0000e+00	# [eV]
	hoffset(0)	= 0.0000e+00	# [eV]
	hoffset(1)	= 0.0000e+00	# [eV]
}


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1.5,	1.5	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 2.2600e+04,	2.5000e+02	#[cm^2/(Vs)]
	mumax(1)	= 2.5000e+03,	1.5000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1.5,	1.5	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 2.2600e+04,	2.5000e+02	#[cm^2/(Vs)]
	mumax(1)	= 2.5000e+03,	1.5000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BalMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BalMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}

vanOverstraetendeMan * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	a(low)(0)	= 4.17000e+6,	2.65000e+6	#[1/cm]
	a(low)(1)	= 4.17000e+6,	2.65000e+6	#[1/cm]
	a(high)(0)	= 4.17000e+6,	2.65000e+6	#[1/cm]
	a(high)(1)	= 2.17000e+6,	2.65000e+6	#[1/cm]
	b(low)(0)	= 2.09000e+6,	2.79000e+6	#[V/cm]
	b(low)(1)	= 2.09000e+6,	2.79000e+6	#[V/cm]
	b(high)(0)	= 2.0900e+6,	2.79000e+6	#[V/cm]
	b(high)(1)	= 2.09000e+6,	2.79000e+6	#[V/cm]
	E0(0)	= 2.1500e+05,	2.30000e+05	#[V/cm]
	E0(1)	= 2.1500e+05,	2.30000e+05	#[V/cm]
	hbarOmega(0)	= 1.0000e+3,	1.0000e+3	#[eV]   These are temp dependent factor and are irrelevant
	hbarOmega(1)	= 1.0000e+3,	1.0000e+3	#[eV]
	beta(low)(0)	= 6.20285,	1.13424	#[1]
	beta(low)(1)	= 6.20285,	1.13424	#[1]
	beta(high)(0)	= 6.20285,	1.13424	#[1]
	beta(high)(1)	= 6.20285,	1.13424	#[1]
	lambda(0)	= 6.3000e-07,	6.3000e-07	#[cm]
	lambda(1)	= 6.3000e-07,	6.3000e-07	#[cm]
}

vanOverstraetendeMan_aniso * Impact Ionization:
{ * G_impact = alpha_n n v_drift_n  +  alpha_p p v_drift_p
  * with alpha = gamma a  exp(-Ecrit gamma/E) for E<E0 (low) and E>E0 (high)
  * with gamma = tanh(hbarOmega/(2kT0)) / tanh(hbarOmega/(2kT))
  * and Ecrit = b (default),
  * or  Ecrit = (beta Eg)/(q lambda) (with BandgapDependence)
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	a(low)(0)	= 4.17000e+6,	4.17000e+6	#[1/cm]
	a(low)(1)	= 4.17000e+6,	4.17000e+6	#[1/cm]
	a(high)(0)	= 4.17000e+6,	4.17000e+6	#[1/cm]
	a(high)(1)	= 4.17000e+6,	4.17000e+6	#[1/cm]
	b(low)(0)	= 8.09000e+5,	8.09000e+5	#[V/cm]
	b(low)(1)	= 8.09000e+5,	8.09000e+5	#[V/cm]
	b(high)(0)	= 8.0900e+5,	8.09000e+5	#[V/cm]
	b(high)(1)	= 8.09000e+5,	8.09000e+5	#[V/cm]
	E0(0)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	E0(1)	= 4.0000e+05,	4.0000e+05	#[V/cm]
	hbarOmega(0)	= 1.0000e+3,	1.0000e+3	#[eV]   These are temp dependent factor and are irrelevant
	hbarOmega(1)	= 1.0000e+3,	1.0000e+3	#[eV]
	beta(low)(0)	= 6.20285,	1.13424	#[1]
	beta(low)(1)	= 6.20285,	1.13424	#[1]
	beta(high)(0)	= 6.20285,	1.13424	#[1]
	beta(high)(1)	= 6.20285,	1.13424	#[1]
	lambda(0)	= 6.3000e-07,	6.3000e-07	#[cm]
	lambda(1)	= 6.3000e-07,	6.3000e-07	#[cm]
}


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  LatticeParameters{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  StressMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(AlAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


}



Material = "InGaAs" {
*  Mole dependent material: InGaAs (x=0) = InAs
*  Mole dependent material: InGaAs (x=1) = GaAs

Epsilon
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 14.55	# [1]
	epsilon(1)	= 13.18	# [1]
}


Epsilon_aniso
{ *  Ratio of the permittivities of material and vacuum

  * epsilon() = epsilon
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	epsilon(0)	= 14.55	# [1]
	epsilon(1)	= 13.18	# [1]
}


RefractiveIndex
{ *  Optical Refractive Index

  * refractiveindex() = refractiveindex * (1 + alpha * (T-Tpar))
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	refractiveindex(0)	= 3.892	# [1]
	refractiveindex(1)	= 3.5108	# [1]
	alpha(0)	= 2.0000e-04	# [1/K]
	alpha(1)	= 4.0000e-04	# [1/K]
	CarrDepCoeff(0)	= 1	# [1]
	CarrDepCoeff(1)	= 1	# [1]

  * Gain dependence of refractive index in active region:
  * a) Linear model: delta n = a0 * ( (n+p)/(2 * N0) - 1)
  * b) Logarithmic model: delta n = a0 * log ( (n+p)/(2 * N0) )
  * where n/p are the carrier densities in the active region. 
	a0	= 0.0000e+00	# [1]
	N0	= 1.0000e+18	# [1/cm^3]
}


ComplexRefractiveIndex
{ *  Complex refractive index model: n_complex = n + i*k (unitless)
  *  
  *  with n = n_0 + delta_n_lambda + delta_n_T + delta_n_carr + delta_n_gain 
  *       k = k_0 + delta_k_lambda             + delta_k_carr                
  
  * Base refractive index and extinction coefficient: 
  *     n_0, k_0 
  
  * Wavelength dependence (real and imag): 
  *     Formula 0: delta_n_lambda = Cn_lambda * lambda + Dn_lambda * lambda^2 
  *                delta_k_lambda = Ck_lambda * lambda + Dk_lambda * lambda^2 
  *     Formula 1: Read tabulated values 
  *                NumericalTable (...)  
  *     Formula 2: Read tabulated values from file 
  *                NumericalTable = <string> 
  
  * Temperature dependence (real): 
  *     delta_n_T = n_0 * ( Cn_temp * (T-Tpar)) 
  
  * Carrier dependence (real) 
  *     delta_n_carr = - Cn_carr * (const.) * (n/m_e + p/m_h) 
  
  * Carrier dependence (imag) 
  *     delta_k_carr = 1 / (4*PI) * (wavelength^Gamma_k_carr_e*Ck_carr_e*n + wavelength^Gamma_k_carr_h*Ck_carr_h*p) 
  
  * Gain dependence (real) 
  *     lin: delta_n_gain = Cn_gain * ( (n+p)/(2 * Npar) - 1) 
  *     log: delta_n_gain = Cn_gain * log ( (n+p)/(2 * Npar ) )
	n_0(0)	= 3.892	# [1]
	n_0(1)	= 3.5108	# [1]
	k_0(0)	= 0.0000e+00	# [1]
	k_0(1)	= 0.0000e+00	# [1]
	Cn_lambda(0)	= 0.0000e+00	# [um^-1]
	Cn_lambda(1)	= 0.0000e+00	# [um^-1]
	Dn_lambda(0)	= 0.0000e+00	# [um^-2]
	Dn_lambda(1)	= 0.0000e+00	# [um^-2]
	Ck_lambda(0)	= 0.0000e+00	# [um^-1]
	Ck_lambda(1)	= 0.0000e+00	# [um^-1]
	Dk_lambda(0)	= 0.0000e+00	# [um^-2]
	Dk_lambda(1)	= 0.0000e+00	# [um^-2]
	Cn_temp(0)	= 2.0000e-04	# [K^-1]
	Cn_temp(1)	= 4.0000e-04	# [K^-1]
	Cn_carr(0)	= 1	# [1]
	Cn_carr(1)	= 1	# [1]
	Cn_gain(0)	= 0.0000e+00	# [1]
	Cn_gain(1)	= 0.0000e+00	# [1]
	Npar(0)	= 1.0000e+18	# [cm^-3]
	Npar(1)	= 1.0000e+18	# [cm^-3]
* Mole fraction dependent model.
* Linear interpolation is used on the interval [0,1].
	Ck_carr(0)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Ck_carr(1)	= 0.0000e+00,	0.0000e+00	#[cm^2]
	Gamma_k_carr(0)	= 1,	1	#[1]
	Gamma_k_carr(1)	= 1,	1	#[1]
        Formula = 1
		NumericalTable(
			#0.49  4.348   0.049521;
			#0.5   4.293   0.044165;
			#0.51  4.239   0.039367;
			#1.51  4.239   0.039367;
			1.4   4.293   0.44165;
			1.5   4.293   0.44165;
			1.6   4.293   0.44165;
		)
	Tpar	= 3.0000e+02	# [K]
} 


* SpectralConversion
* { * Spectral Conversion Model
*   No default model, user has to define.
*   All wavelength parameters should be in nanometers.
*   Choice of Analytic or NumericalTable selected in Physics section of region
*  
*   ConversionEfficiency = float     * ratio of absorbed photons that are reemitted.
*   AbsorptionScaling = float        * scale absorption
*   EmissionScaling = float          * scale emission
*   Analytic (
*     AbsorptionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*     EmissionProfile = (
*        Gaussian(lambda0 sigma peakvalue dc_offset lambda_range0 lambda_range1)
*        Lorentzian(lambda0 width peakvalue dc_offset lambda_range0 lambda_range1)
*        ...
*     )
*   )
*   NumericalTable (
*     AbsorptionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )
*     EmissionProfile = (
*        lambda0 value0
*        lambda1 value1
*        ...
*     )

*   ConversionEfficiency = 1.0
* }


LatticeHeatCapacity
{ *  lumped electron-hole-lattice heat capacity

  * cv() = cv + cv_b * T + cv_c * T^2 + cv_d * T^3 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	cv(0)	= 1.6	# [J/(Kcm^3)]
	cv(1)	= 1.6	# [J/(Kcm^3)]
	cv_b(0)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_b(1)	= 0.0000e+00	# [J/(K^2*cm^3)]
	cv_c(0)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_c(1)	= 0.0000e+00	# [J/(K^3*cm^3)]
	cv_d(0)	= 0.0000e+00	# [J/(K^4*cm^3)]
	cv_d(1)	= 0.0000e+00	# [J/(K^4*cm^3)]
}


Kappa
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 3.7	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 2.17391	# [(K cm)/W]
	B(1/kappa(1))	= -2.3000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


Kappa_aniso
{ *  Lattice thermal conductivity

  * Formula = 0:
  * kappa() = 1 / ( 1/kappa + 1/kappa_b * T + 1/kappa_c * T^2 )
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa(0)	= 1.5	# [W/(K cm)]
	Xmax(1)	= 1	# [1]
	kappa(1)	= 1.5	# [W/(K cm)]
	B(kappa(1))	= 0.0000e+00	# [W/(K cm)]
	C(kappa(1))	= 0.0000e+00	# [W/(K cm)]

	* parameter kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_b(0)	= 0.0000e+00	# [W/(K^2 cm)]
	Xmax(1)	= 1	# [1]
	kappa_b(1)	= 0.0000e+00	# [W/(K^2 cm)]
	B(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]
	C(kappa_b(1))	= 0.0000e+00	# [W/(K^2 cm)]

	* parameter kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	kappa_c(0)	= 0.0000e+00	# [W/(K^3 cm)]
	Xmax(1)	= 1	# [1]
	kappa_c(1)	= 0.0000e+00	# [W/(K^3 cm)]
	B(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]
	C(kappa_c(1))	= 0.0000e+00	# [W/(K^3 cm)]

	* parameter 1/kappa:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa(0)	= 3.7	# [(K cm)/W]
	Xmax(1)	= 1	# [1]
	1/kappa(1)	= 2.17391	# [(K cm)/W]
	B(1/kappa(1))	= -2.3000e+01	# [(K cm)/W]
	C(1/kappa(1))	= 0.0000e+00	# [(K cm)/W]

	* parameter 1/kappa_b:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_b(0)	= 0.0000e+00	# [cm/W]
	Xmax(1)	= 1	# [1]
	1/kappa_b(1)	= 0.0000e+00	# [cm/W]
	B(1/kappa_b(1))	= 0.0000e+00	# [cm/W]
	C(1/kappa_b(1))	= 0.0000e+00	# [cm/W]

	* parameter 1/kappa_c:
	Xmax(0)	= 0.0000e+00	# [1]
	1/kappa_c(0)	= 0.0000e+00	# [cm/(W K)]
	Xmax(1)	= 1	# [1]
	1/kappa_c(1)	= 0.0000e+00	# [cm/(W K)]
	B(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]
	C(1/kappa_c(1))	= 0.0000e+00	# [cm/(W K)]

}


EnergyRelaxationTime
{ *  Energy relaxation times in picoseconds
	tau_w_ele	= 1	# [ps]
	tau_w_hol	= 0.4	# [ps]

 * Below is the example of energy relaxation time approximation
 * by the ratio of two irrational polynomials.
 * If Wmax(interval-1) < Wc < Wmax(interval), then:
 * tau_w = (tau_w)*(Numerator^Gn)/(Denominator^Gd),
 * where (Numerator or Denominator)=SIGMA[A(i)(Wc^P(i))],
 * Wc=1.5(k*Tcar)/q (in eV).
 * By default: Wmin(0)=Wmax(-1)=0; Wmax(0)=infinity.
 * The option can be activated by specifying appropriate Formula equal to 2.
 *      Formula(tau_w_ele) = 2
 *      Formula(tau_w_hol) = 2
 *      Wmax(interval)_ele = 
 *      tau_w_ele(interval)     =     
 *      Numerator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        A(1)  = 
 *        P(1)  = 
 *        G     = 
 *      }
 *      Denominator(interval)_ele{
 *        A(0)  = 
 *        P(0)  = 
 *        G     = 
 *      }

 * Note: Energy relaxation times can be either molefraction dependent
 *       or energy dependent, but not both!

 *      Wmax(interval)_hol = 
 *      tau_w_hol(interval)     =  
}

AvalancheFactors
{ *  Coefficientss for avalanche generation with hydro
  *  Factors n_l_f, p_l_f for energy relaxation length in the expressions
  *  for effective electric field for avalanche generation
  *  eEeff = eEeff / n_l_f  ( or b = b*n_l_f ) 
  *  hEeff = hEeff / p_l_f  ( or b = b*p_l_f ) 
  *  Additional coefficients n_gamma, p_gamma, n_delta, p_delta 
	n_l_f	= 0.8	# [1]
	p_l_f	= 0.8	# [1]
	n_gamma	= 0.0000e+00	# [1]
	p_gamma	= 0.0000e+00	# [1]
	n_delta	= 0.0000e+00	# [1]
	p_delta	= 0.0000e+00	# [1]
}

Bandgap
{ * Eg = Eg0 + alpha Tpar^2 / (beta + Tpar) - alpha T^2 / (beta + T)
  * Parameter 'Tpar' specifies the value of lattice 
  * temperature, at which parameters below are defined
  * Chi0 is electron affinity.
	Tpar	= 3.0000e+02	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * The following interpolation polynom can be used on interval [Xmin(I),Xmax(I)]:
  * F(X) = F(I-1)+A(I)*(X-Xmin(I))+B(I)*(X-Xmin(I))^2+C(I)*(X-Xmin(I))^3,
  * where Xmax(I), F(I), B(I), C(I) are defined below for each interval.
  * A(I) is calculated for a boundary condition F(Xmax(I)) = F(I).
  *
  * Definition of mole fraction intervals, parameters, and coefficients:
	* parameter dEg0(OldSlotboom):
	Eg0 = 8.00e-1 #hard code bandgap
	Eg0(0) = 8.00e-1 

	* parameter Bgn2Chi:
	Xmax(0)	= 0.0000e+00	# [1]
	Bgn2Chi(0)	= 0.5	# [1]
	Xmax(1)	= 1	# [1]
	Bgn2Chi(1)	= 0.5	# [1]
	B(Bgn2Chi(1))	= 0.0000e+00	# [1]
	C(Bgn2Chi(1))	= 0.0000e+00	# [1]

	* parameter alpha:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha(0)	= 3.3500e-04	# [eV/K]
	Xmax(1)	= 1	# [1]
	alpha(1)	= 5.4050e-04	# [eV/K]
	B(alpha(1))	= 0.0000e+00	# [eV/K]
	C(alpha(1))	= 0.0000e+00	# [eV/K]

	* parameter alpha2:
	Xmax(0)	= 0.0000e+00	# [1]
	alpha2(0)	= 0.0000e+00	# [eV/K]
	Xmax(1)	= 1	# [1]
	alpha2(1)	= 0.0000e+00	# [eV/K]
	B(alpha2(1))	= 0.0000e+00	# [eV/K]
	C(alpha2(1))	= 0.0000e+00	# [eV/K]

	* parameter beta:
	Xmax(0)	= 0.0000e+00	# [1]
	beta(0)	= 2.4800e+02	# [K]
	Xmax(1)	= 1	# [1]
	beta(1)	= 2.0400e+02	# [K]
	B(beta(1))	= 0.0000e+00	# [K]
	C(beta(1))	= 0.0000e+00	# [K]

	* parameter beta2:
	Xmax(0)	= 0.0000e+00	# [1]
	beta2(0)	= 0.0000e+00	# [K]
	Xmax(1)	= 1	# [1]
	beta2(1)	= 0.0000e+00	# [K]
	B(beta2(1))	= 0.0000e+00	# [K]
	C(beta2(1))	= 0.0000e+00	# [K]

	* parameter Chi0:
	Xmax(0)	= 0.0000e+00	# [1]
	Chi0(0)	= 4.92751	# [eV]
	Xmax(1)	= 1	# [1]
	Chi0(1)	= 4.11826	# [eV]
	B(Chi0(1))	= 0.0000e+00	# [eV]
	C(Chi0(1))	= 0.0000e+00	# [eV]

	* parameter WorkFunction:
	Xmax(0)	= 0.0000e+00	# [1]
	WorkFunction(0)	= 4.25	# [eV]
	Xmax(1)	= 1	# [1]
	WorkFunction(1)	= 4.25	# [eV]
	B(WorkFunction(1))	= 0.0000e+00	# [eV]
	C(WorkFunction(1))	= 0.0000e+00	# [eV]

	* parameter FermiEnergy:
	Xmax(0)	= 0.0000e+00	# [1]
	FermiEnergy(0)	= 11.7	# [eV]
	Xmax(1)	= 1	# [1]
	FermiEnergy(1)	= 11.7	# [eV]
	B(FermiEnergy(1))	= 0.0000e+00	# [eV]
	C(FermiEnergy(1))	= 0.0000e+00	# [eV]

	* parameter EgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	EgMin(0)	= -1.0000e+01	# [eV]
	Xmax(1)	= 1	# [1]
	EgMin(1)	= -1.0000e+01	# [eV]
	B(EgMin(1))	= 0.0000e+00	# [eV]
	C(EgMin(1))	= 0.0000e+00	# [eV]

	* parameter dEgMin:
	Xmax(0)	= 0.0000e+00	# [1]
	dEgMin(0)	= 0.0000e+00	# [eV]
	Xmax(1)	= 1	# [1]
	dEgMin(1)	= 0.0000e+00	# [eV]
	B(dEgMin(1))	= 0.0000e+00	# [eV]
	C(dEgMin(1))	= 0.0000e+00	# [eV]

}


*  OldSlotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Slotboom { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  delAlamo { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Bennett { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

JainRoulston
{ * deltaEg = A_i N^(1/3) + B_i N^(1/4) + C_i N^(1/2) + D_i N^(1/2)
  * where i is n for n-type or p for p-type
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A_n(0)	= 0.0000e+00	# [eV cm]
	A_n(1)	= 0.0000e+00	# [eV cm]
	B_n(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_n(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_n(1)	= 0.0000e+00	# [eV cm^(3/2)]
	A_p(0)	= 0.0000e+00	# [eV cm]
	A_p(1)	= 0.0000e+00	# [eV cm]
	B_p(0)	= 0.0000e+00	# [eV cm^(3/4)]
	B_p(1)	= 0.0000e+00	# [eV cm^(3/4)]
	C_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	C_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(0)	= 0.0000e+00	# [eV cm^(3/2)]
	D_p(1)	= 0.0000e+00	# [eV cm^(3/2)]
}

FreeCarrierAbsorption
{
  * Coefficients for free carrier absorption:
  * fcaalpha_n for electrons,
  * fcaalpha_p for holes

  * FCA = (alpha_n * n + alpha_p * p) * Light Intensity
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	fcaalpha_n(0)	= 4.0000e-18	# [cm^2]
	fcaalpha_n(1)	= 4.0000e-18	# [cm^2]
	fcaalpha_p(0)	= 8.0000e-18	# [cm^2]
	fcaalpha_p(1)	= 8.0000e-18	# [cm^2]
}

BandstructureParameters
{
  * Parameters for k.p bandstructure calculation:

  * Zincblende crystals:
  * Luttinger parameters gamma_1, gamma_2, gamma_3
  * Spin-orbit split-off energy so
  * Matrix element parameters for TE and TM modes ep_te and ep_tm

  * Wurtzite crystals:
  * Effective mass parameters A1, A2, A3, A4, A5, A6
  * Spin-orbit split-off energy so
  * Crystal-field split  energy cr
  * Matrix element parameters for TE and TM modes ep_te and ep_tm
  * 
  * 

  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	gamma_1(0)	= 20.4	# [1]
	gamma_1(1)	= 6.85	# [1]
	gamma_2(0)	= 8.3	# [1]
	gamma_2(1)	= 2.1	# [1]
	gamma_3(0)	= 9.1	# [1]
	gamma_3(1)	= 2.9	# [1]
	so(0)	= 0.38	# [eV]
	so(1)	= 0.34	# [eV]
	ep_te(0)	= 21.5	# [eV]
	ep_te(1)	= 28.8	# [eV]
	ep_tm(0)	= 21.5	# [eV]
	ep_tm(1)	= 28.8	# [eV]
	A1(0)	= 0.0000e+00	# [1]
	A1(1)	= 0.0000e+00	# [1]
	A2(0)	= 0.0000e+00	# [1]
	A2(1)	= 0.0000e+00	# [1]
	A3(0)	= 0.0000e+00	# [1]
	A3(1)	= 0.0000e+00	# [1]
	A4(0)	= 0.0000e+00	# [1]
	A4(1)	= 0.0000e+00	# [1]
	A5(0)	= 0.0000e+00	# [1]
	A5(1)	= 0.0000e+00	# [1]
	A6(0)	= 0.0000e+00	# [1]
	A6(1)	= 0.0000e+00	# [1]
	cr(0)	= 0.0000e+00	# [eV]
	cr(1)	= 0.0000e+00	# [eV]
}

QWStrain
{
  * Zincblende crystals:
  *   Parameters: a_nu, a_c, b, C_12, C_11
  *   StrainConstant eps (formula = 1) or lattice constant
  *   a0 (formula = 2) for energy shift of quantum-well
  *   subbands.
  *   a0(T) = a0 + alpha (T-Tpar)

  * Wurtzite crystals:
  *   Parameters: a_c, D1, D2, D3, D4, C_13, C_33
  *   Lattice constants a0 and c0 (formula 2 must be used)
  *   a0(T) = a0 + alpha (T-Tpar)
  *   c0(T) = c0 + alpha (T-Tpar)

	  * Default formula	= 1	# [1]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a_nu(0)	= 1	# [eV]
	a_nu(1)	= 1.16	# [eV]
	a_c(0)	= -5.0800e+00	# [eV]
	a_c(1)	= -7.1700e+00	# [eV]
	b_shear(0)	= -1.8000e+00	# [eV]
	b_shear(1)	= -1.7000e+00	# [eV]
	C_11(0)	= 8.329	# [1e-2 GPa]
	C_11(1)	= 11.879	# [1e-2 GPa]
	C_12(0)	= 4.526	# [1e-2 GPa]
	C_12(1)	= 5.376	# [1e-2 GPa]
	eps(0)	= 0.0000e+00	# [1]
	eps(1)	= 0.0000e+00	# [1]
	a0(0)	= 6.0583e-10	# [m]
	a0(1)	= 5.6533e-10	# [m]
	alpha(0)	= 2.7400e-15	# [m/K]
	alpha(1)	= 3.8800e-15	# [m/K]
	D1(0)	= 0.0000e+00	# [eV]
	D1(1)	= 0.0000e+00	# [eV]
	D2(0)	= 0.0000e+00	# [eV]
	D2(1)	= 0.0000e+00	# [eV]
	D3(0)	= 0.0000e+00	# [eV]
	D3(1)	= 0.0000e+00	# [eV]
	D4(0)	= 0.0000e+00	# [eV]
	D4(1)	= 0.0000e+00	# [eV]
	C_13(0)	= 0.0000e+00	# [1e-2 GPa]
	C_13(1)	= 0.0000e+00	# [1e-2 GPa]
	C_33(0)	= 0.0000e+00	# [1e-2 GPa]
	C_33(1)	= 0.0000e+00	# [1e-2 GPa]
	c0(0)	= 0.0000e+00	# [cm]
	c0(1)	= 0.0000e+00	# [cm]
}

eDOSMass
{
  * For effective mass specification Formula1 (me approximation):
  * or Formula2 (Nc300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * me/m0 = (Nc300/2.5094e19)^2/3 
  * Nc(T) = Nc300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.1905	# [1]
	a(1)	= 0.1905	# [1]
	ml(0)	= 0.9163	# [1]
	ml(1)	= 0.9163	# [1]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nc300(0)	= 8.7200e+16	# [cm-3]
	Nc300(1)	= 4.4200e+17	# [cm-3]
}

hDOSMass
{
  * For effective mass specification Formula1 (mh approximation):
  * or Formula2 (Nv300) can be used :
	Formula	= 2	# [1]
  * Formula2:
  * mh/m0 = (Nv300/2.5094e19)^2/3 
  * Nv(T) = Nv300 * (T/300)^3/2 
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	a(0)	= 0.443587	# [1]
	a(1)	= 0.443587	# [1]
	b(0)	= 3.6095e-03	# [K^-1]
	b(1)	= 3.6095e-03	# [K^-1]
	c(0)	= 1.1735e-04	# [K^-2]
	c(1)	= 1.1735e-04	# [K^-2]
	d(0)	= 1.2632e-06	# [K^-3]
	d(1)	= 1.2632e-06	# [K^-3]
	e(0)	= 3.0256e-09	# [K^-4]
	e(1)	= 3.0256e-09	# [K^-4]
	f(0)	= 4.6834e-03	# [K^-1]
	f(1)	= 4.6834e-03	# [K^-1]
	g(0)	= 2.2869e-04	# [K^-2]
	g(1)	= 2.2869e-04	# [K^-2]
	h(0)	= 7.4693e-07	# [K^-3]
	h(1)	= 7.4693e-07	# [K^-3]
	i(0)	= 1.7275e-09	# [K^-4]
	i(1)	= 1.7275e-09	# [K^-4]
	mm(0)	= 0.0000e+00	# [1]
	mm(1)	= 0.0000e+00	# [1]
	Nv300(0)	= 6.6600e+18	# [cm-3]
	Nv300(1)	= 8.4700e+18	# [cm-3]
}

SchroedingerParameters:
{ * For the hole masses for Schroedinger equation you can
  * use different formulas.
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    m(k)/m0=1/(A+-sqrt(B+C*((xy)^2+(yz)^2+(zx)^2)))
  *    where k=(x,y,z) is unit normal vector in reziprocal
  *    space.  '+' for light hole band, '-' for heavy hole band
  * 2: Heavy hole mass mh and light hole mass ml are
  *    specified explicitly.
  *    Use me as electron mass for free-carrier effect in 
  *    the refractive index model.
  * For electron masses, the following formula options exist:
  * 0: use the isotropic density of states effective mass
  * 1: (for materials with Si-like hole band structure)
  *    use the a, ml, and mm parameters from eDOSMass.
  *    Typically, this leads to anisotropy.
	formula	= 0 ,	2	# [1]
  * Lifting of degeneracy of bulk valleys. The value for
  * electrons is added to the band edge for the subband
  * ladder of lower degeneracy if positive, and subtracted
  * from the band edge for the ladder of higher degeneracy
  * if negative. (that is, the value of the band edge is
  * always increased).  For holes, the value is subtracted from
  * the band edge for the heavy hole band is positive,
  * add added tp that of the light hole band if
  * negative.  The signs are such that the shift always
  * moves the band edges 'outward', away from midgap.  The
  * gap itself is defined as the separation of the
  * unshifted band edges and remains unaffected.
	offset	= 0.0000e+00 ,	0.0000e+00	# [eV]
  * Alternative to the specification of formula, offset,
  * and masses, you can make an arbitrary number of ladder
  * specification, 'eLadder(mz, mxy, deg, dE) and hLadder(...)
  * Here, mz is the quantization mass, mxy an in-plane DOS mass,
  * deg the ladder degeneracy, and dE an shift of the band edge
  * for the ladder (non-negative; the shift is always outward,
  * away from midgap).  When present, we solve the Schroedinger
  * equation separately for each ladder

  * Temperatures in rescaling of the mxy for eLadder and hLadder
	ShiftTemperature	= 1.0000e+10 ,	1.0000e+10	# [K]
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	A(0)	= 4.22	# [1]
	A(1)	= 4.22	# [1]
	B(0)	= 0.6084	# [1]
	B(1)	= 0.6084	# [1]
	C(0)	= 23.058	# [1]
	C(1)	= 23.058	# [1]
	ml(0)	= 0.024	# [1]
	ml(1)	= 0.074	# [1]
	mh(0)	= 0.41	# [1]
	mh(1)	= 0.62	# [1]
	me(0)	= 0.0000e+00	# [1]
	me(1)	= 0.0000e+00	# [1]
	eoffset(0)	= 0.0000e+00	# [eV]
	eoffset(1)	= 0.0000e+00	# [eV]
	hoffset(0)	= 0.0000e+00	# [eV]
	hoffset(1)	= 0.0000e+00	# [eV]
}


*  QuantumPotentialParameters { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

ConstantMobility:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1.5,	1.5	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 2.2600e+04,	2.5000e+02	#[cm^2/(Vs)]
	mumax(1)	= 8.5000e+03,	4.0000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}

ConstantMobility_aniso:
{ * mu_const = mumax (T/T0)^(-Exponent)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	Exponent(0)	= 1.5,	1.5	#[1]
	Exponent(1)	= 1,	2.1	#[1]
	mumax(0)	= 2.2600e+04,	2.5000e+02	#[cm^2/(Vs)]
	mumax(1)	= 8.5000e+03,	4.0000e+02	#[cm^2/(Vs)]
	mutunnel(0)	= 0.05,	0.05	#[cm^2/(Vs)]
	mutunnel(1)	= 0.05,	0.05	#[cm^2/(Vs)]
}


*  DopingDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  DopingDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PhuMob{...} 
*  Philips Unified Mobility Model:
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BalMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  BalMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EnormalDependence_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  ThinLayerMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  IALMob_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  EffectiveStressModel{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  NegInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  PosInterfaceChargeMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Coulomb2DMobility_aniso{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

HighFieldDependence:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

HighFieldDependence_aniso:
{ * Caughey-Thomas model:
  * mu_highfield = ( (alpha+1)*mu_lowfield ) / 
  *        ( alpha + ( 1 + ( (alpha+1)*mu_lowfield*E/vsat)^beta )^(1/beta) ) 
  * beta = beta0 (T/T0)^betaexp.
 * For vsat either Formula1 or Formula2 can be used.
	Vsat_Formula	= 2 ,	2	# [1]
 * Formula2 for saturation velocity:
 *            vsat = A_vsat - B_vsat*(T/T0)
 * (Parameter Vsat_Formula has to be equal to 2)
  * Mole fraction dependent model.
  * If only constant parameters are specified, those values will be
  * used for any mole fraction instead of the interpolation below.
  * Linear interpolation is used on the interval [0,1].
	beta0(0)	= 2,	2	#[1]
	beta0(1)	= 2,	2	#[1]
	betaexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	betaexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(0)	= 0.0000e+00,	0.0000e+00	#[1]
	alpha(1)	= 0.0000e+00,	0.0000e+00	#[1]
	K_dT(0)	= 0.2,	0.2	#[1]
	K_dT(1)	= 0.2,	0.2	#[1]
	E0_TrEf(0)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	E0_TrEf(1)	= 4.0000e+03,	4.0000e+03	#[V/cm]
	Ksmooth_TrEf(0)	= 1,	1	#[1]
	Ksmooth_TrEf(1)	= 1,	1	#[1]
	vsat0(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	vsat0(1)	= 7.7000e+06,	7.7000e+06	#[cm/s]
	vsatexp(0)	= 0.0000e+00,	0.0000e+00	#[1]
	vsatexp(1)	= 0.0000e+00,	0.0000e+00	#[1]
	A_vsat(0)	= 1.0000e+07,	1.0000e+07	#[cm/s]
	A_vsat(1)	= 1.1300e+07,	1.1300e+07	#[cm/s]
	B_vsat(0)	= 0.0000e+00,	0.0000e+00	#[cm/s]
	B_vsat(1)	= 3.6000e+06,	3.6000e+06	#[cm/s]
	vsat_min(0)	= 5.0000e+05,	5.0000e+05	#[cm/s]
	vsat_min(1)	= 5.0000e+05,	5.0000e+05	#[cm/s]
}

Scharfetter * relation and trap level for SRH recombination:
{ * tau = taumin + ( taumax - taumin ) / ( 1 + ( N/Nref )^gamma)
  * tau(T) = tau * ( (T/300)^Talpha )          (TempDep)
  * tau(T) = tau * exp( Tcoeff * ((T/300)-1) ) (ExpTempDep)
	taumin	= 0.0000e+00 ,	0.0000e+00	# [s]
	taumax	= 1.0000e-09 ,	1.0000e-09	# [s]
	Nref	= 1.0000e+16 ,	1.0000e+16	# [cm^(-3)]
	gamma	= 1 ,	1	# [1]
	Talpha	= 0.0000e+00 ,	0.0000e+00	# [1]
	Tcoeff	= 0.0000e+00 ,	0.0000e+00	# [1]
	Etrap	= 0.0000e+00	# [eV]
}

Auger * coefficients:
{ * R_Auger = ( C_n n + C_p p ) ( n p - ni_eff^2)
  * with C_n,p = (A + B (T/T0) + C (T/T0)^2) (1 + H exp(-{n,p}/N0))
	A	= 1.0000e-30 ,	1.0000e-30	# [cm^6/s]
	B	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	C	= 0.0000e+00 ,	0.0000e+00	# [cm^6/s]
	H	= 0.0000e+00 ,	0.0000e+00	# [1]
	N0	= 1.0000e+18 ,	1.0000e+18	# [cm^(-3)]
}


*  SHEDistribution{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  Radiative Recombination Model{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.


*  MLDAQMModel { ... } 
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

MultiValley
{ * Arbitrary number of electron and hole valleys can be defined. 
  * Electron density is written as: n=Nc*sum{d_i*F1/2((Ef-Ec-dEc_i)/kT)}, 
  * where dEc_i is energy shift, d_i is DOS factor (defined by valley masses 
  * and degeneracy) of valley i. To specify one valley the energy shift 
  * in respect to band edge, degeneracy, non parabolicity, effective masses, 
  * and valley orientation should be defined. The interface quantization mass
  * (for MLDA model) will be compute automatically (using valley inverse mass 
  * tensor and interface orientation). If the quantization mass is specified, 
  * then it'll be independent of the interface orientation.
	eValley"Gamma"(m=0.0244 energy=0.0000e+00 alpha=1.39 dospower=0.5 degeneracy=1 xid=-1.0200e+01) 
	eValley"L1"(1,1,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 dospower=0.5 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L2"(-1.0000e+00,1,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 dospower=0.5 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L3"(1,-1.0000e+00,1)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 dospower=0.5 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"L4"(1,1,-1.0000e+00)(ml=1.634 mt=0.108 energy=0.712 alpha=0.536 dospower=0.5 degeneracy=1 xiu=9.5 xid=-2.0000e+00) 
	eValley"X1"(1,0.0000e+00,0.0000e+00)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 dospower=0.5 degeneracy=1 xiu=4.5 xid=1.6) 
	eValley"X2"(0.0000e+00,1,0.0000e+00)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 dospower=0.5 degeneracy=1 xiu=4.5 xid=1.6) 
	eValley"X3"(0.0000e+00,0.0000e+00,1)(ml=3.75 mt=0.363 energy=1.012 alpha=0.9 dospower=0.5 degeneracy=1 xiu=4.5 xid=1.6) 
	hValley"LH"(m=0.082 energy=0.0000e+00 alpha=0.0000e+00 dospower=0.5 degeneracy=1) 
	hValley"HH"(m=0.51 energy=0.0000e+00 alpha=0.0000e+00 dospower=0.5 degeneracy=1) 
	Xmax(0) = 0.0
	Xmax(1) = 1
	eValley"Gamma"(1)(m=0.065 energy=0.0000e+00 alpha=0.61 degeneracy=1 xid=-1.1000e+01) 
	eValley"L1"(1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L2"(1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L3"(1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"L4"(1)(ml=1.521 mt=0.129 energy=0.292 alpha=0.461 degeneracy=1 xiu=14.1 xid=-2.0000e+00) 
	eValley"X1"(1)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	eValley"X2"(1)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	eValley"X3"(1)(ml=1.714 mt=0.26 energy=0.483 alpha=0.204 degeneracy=1 xiu=9.3 xid=1.1) 
	hValley"LH"(1)(m=0.026 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
	hValley"HH"(1)(m=0.41 energy=0.0000e+00 alpha=0.0000e+00 degeneracy=1) 
}

LatticeParameters
{ * Crystal system, elasticity, and deformation potential are defined.
  * X and Y vectors define the simulation coordinate system relative to the
  * crystal orientation system. Also there is an option to represent the crystal
  * system relative to the simulation one. In this case a keyword CrystalAxis 
  * has to be in this section and X and Y vectors will represent [100] and [010]
  * axis of the crystal system in the simulation one.
  * Additional notes: 1 Pa = 10 dyn/cm^2; tensile stress/strain is positive. 
  *  
  * S[i][j] - elasticity modulus; i,j = 1,2,...6 and j>=i.
  * CrystalSystem is symmetry, used ONLY to define the elasticity matrics.
  *   Cubic (CrystalSystem=0): S[1][1],S[1][2],S[4][4]
  *   Hexagonal (CrystalSystem=1): S[1][1],S[1][2],S[1][3],S[3][3],S[4][4]
  * 
	X	= (1, 0.0000e+00, 0.0000e+00) #[1]
	Y	= (0.0000e+00, 1, 0.0000e+00) #[1]
	S[1][1]	= 1.9	# [1e-12 cm^2/din]
	S[1][2]	= -6.9000e-01	# [1e-12 cm^2/din]
	S[4][4]	= 2.5	# [1e-12 cm^2/din]
	CrystalSystem	= 0	# [1]

  * Deformation potentials of 2 k.p model for electron delta-valleys 
	xis	= 0.0000e+00	# [eV]
	dbs	= 0.0000e+00	# [eV]
	xiu	= 4.5	# [eV]
	xid	= 1.6	# [eV]
	Mkp	= 1	# [1]

  * Deformation potentials of 6 k.p model for hole bands
	adp	= 1	# [eV]
	bdp	= -1.8000e+00	# [eV]
	ddp	= -3.6000e+00	# [eV]
	dso	= 0.394	# [eV]

  * Luttinger parameters
	gamma_1	= 14.46	# [1]
	gamma_2	= 5.74	# [1]
	gamma_3	= 6.59	# [1]

  * Deformation potentials and energy (in reference to delta-valley) for L-valleys 
	xiu_l	= 9.5	# [eV]
	xid_l	= -2.0000e+00	# [eV]
	e_l	= -3.0000e-01	# [eV]

  * Deformation potentials and energy (in reference to delta-valley) for Gamma-valley 
	xid_gamma	= -1.0200e+01	# [eV]
	e_gamma	= -1.0100e+00	# [eV]
  * 
    Xmax(0) = 0.0 
    Xmax(1) = 1.0 
  * 
	S[1][1](1)	= 1.2	# [1e-12 cm^2/din]
	S[1][2](1)	= -3.6000e-01	# [1e-12 cm^2/din]
	S[4][4](1)	= 1.7	# [1e-12 cm^2/din]
  * 
	xis(1)	= 0.0000e+00	# [eV]
	dbs(1)	= 0.0000e+00	# [eV]
	xiu(1)	= 9.3	# [eV]
	xid(1)	= 1.1	# [eV]
	Mkp(1)	= 1	# [1]

  * 
	adp(1)	= -8.5000e-01	# [eV]
	bdp(1)	= -1.8500e+00	# [eV]
	ddp(1)	= -5.1000e+00	# [eV]
	dso(1)	= 0.347	# [eV]

  * 
	gamma_1(1)	= 7.02	# [1]
	gamma_2(1)	= 2.27	# [1]
	gamma_3(1)	= 2.99	# [1]

  * 
	xiu_l(1)	= 14.1	# [eV]
	xid_l(1)	= -2.0000e+00	# [eV]
	e_l(1)	= -1.9000e-01	# [eV]

  * 
	xid_gamma(1)	= -1.1000e+01	# [eV]
	e_gamma(1)	= -4.8000e-01	# [eV]
}


*  Piezoelectric_Polarization{...}
*  By default, for mole fraction dependency of parameters
*  of the model, the following linear interpolation is applied
*  between two materials: P = x * P(GaAs) + (1-x) * P(InAs)
*  where P(m) is a parameter of material m.
*  If the parameters are specified, then their values
*  will be used instead of the interpolation.

StressMobility
{ * Stress-induced electron channel mobility model.
  * The model is based on 2 band k.p theory for electron bands and 
  * intervalley/intravelly scattering model with acoustic and optical phonons.
	Ephonon	= 0.03	# [eV]
	beta	= 1.22	# [1]
	beta_mlda	= (1.5, 1.5, 1.5) #[1]
	Nref	= 3.0000e+19	# [cm^-3]
	alpha	= 0.65	# [1]
	Dop	= 6.0000e+08	# [eV/cm]
	Dac_cl	= 1.6000e-05	# [eVs/cm]
  * 
  * Stress-induced change of delta2 electron mass proposed by TU Vienna.
  * The model is based on 2 band k.p theory for electron bands,
  * k.p parameters of the model are defined in LatticeParameters section. 
  * me_l0 and me_t0 are unstressed longitudinal and transverse effective masses:
	me_l0	= 3.75	# [1]
	me_t0	= 0.363	# [1]
  * 
  * Relaxed effective masses of electrons in L-valleys:
	me_l0_l	= 1.634	# [1]
	me_t0_l	= 0.108	# [1]
  * 
  * Relaxed effective mass of electrons in Gamma-valley:
	me0_gamma	= 0.0244	# [1]
  * 
  * Stress-induced hole channel mobility model.
  * The model is based on 6 band k.p hole bands and MLDA channel quantization,
  * k.p parameters of the model are defined in LatticeParameters section. 
	Ephonon_h	= 0.03	# [eV]
	Dop_h	= 6.0000e+08	# [eV/cm]
	Dac_cl_h	= 1.0000e-05	# [eVs/cm]
	beta_h	= 1.0000e+10	# [1]
	beta_mlda_h	= (3, 1.5, 2.5) #[1]
	Nref_h	= 3.0000e+19	# [cm^-3]
	alpha_h	= 0.85	# [1]
  * 
  * Stress-induced hole mobility model is proposed by Intel:
  * the hole band structure in 100 plane is described by two ellipsoids directed in 
  * 110 and -110 directions, the multiplication factor of hole mobility in 110 direction
  * is the following:
  *             fh_110 = (f_110/mh_l0+f_'110/mh_t'110)/(0.5/mh_l0+0.5/mh_t0),
  * where:
  *   f_110 = 1/(1+exp(delta/kT), f_'110 = 1/(1+exp(-delta/kT) - occupation of
  *           the ellipsoids if just two (ne) considered in the hole band
  *   mh_l0 is the hole longitudinal mass in the ellipsoid at no stress
  *   mh_t0 is the hole transverse mass in the ellipsoid at no stress
  *   delta is stress-induced energy split between the ellipsoids
  * 
  *   delta = d1*s
  *   mh_t110 = mh_t0/(1-st1*s+st2*s^2+bt1*b+bt2*b^2)
  *   mh_t'110 = mh_t0/(1+st1*s+st2*s^2+bt1*b+bt2*b^2)
  *      (s is shear and b is biaxial components of the stress)
  * 
  * Modification of the Intel model:
  *   1) considered three 100 plans (6 ellipsoids)
  *   2) ne is number of ellipsoids in the occupation functions fh*
  *   3) considered mass in 100 direction: mh_t100 = mh_t0/(1+btt*b)
	mh_l0	= 0.48	# [1]
	mh_t0	= 0.15	# [1]
	d1	= -6.0000e-11	# [eV/Pa]
	st1	= -9.4426e-10	# [1/Pa]
	st2	= 4.3066e-19	# [1/Pa^2]
	bt1	= -1.0086e-10	# [1/Pa]
	bt2	= 6.5886e-21	# [1/Pa^2]
	btt	= 1.2000e-10	# [1/Pa]
	ne	= 2	# [1]
  * 
    Xmax(0) = 0.0 
    Xmax(1) = 1.0 
  * 
	me_l0(1)	= 1.714	# [1]
	me_t0(1)	= 0.26	# [1]
	me_l0_l(1)	= 1.521	# [1]
	me_t0_l(1)	= 0.129	# [1]
  * 
	me0_gamma(1)	= 0.065	# [1]
  * 
	Ephonon(1)	= 0.03	# [eV]
	beta(1)	= 1.22	# [1]
	beta_mlda(1)	= (1.5, 1.5, 1.5) #[1]
	Nref(1)	= 3.0000e+19	# [cm^-3]
	alpha(1)	= 0.65	# [1]
	Dop(1)	= 5.6000e+08	# [eV/cm]
	Dac_cl(1)	= 1.2000e-05	# [eVs/cm]
  * 
	Ephonon_h(1)	= 0.03	# [eV]
	Dop_h(1)	= 6.0000e+08	# [eV/cm]
	Dac_cl_h(1)	= 1.0000e-05	# [eVs/cm]
	beta_h(1)	= 1.0000e+10	# [1]
	beta_mlda_h(1)	= (3, 1.5, 2.5) #[1]
	Nref_h(1)	= 3.0000e+19	# [cm^-3]
	alpha_h(1)	= 0.85	# [1]
}


}

* Copyright (c) 1994-2015 Synopsys, Inc.
* This parameter file and the associated documentation are proprietary
* to Synopsys, Inc.  This parameter file may only be used in accordance
* with the terms and conditions of a written license agreement with
